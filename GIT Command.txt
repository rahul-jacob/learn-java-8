------------------------------------------------
To display all the files that are tracked by git
------------------------------------------------
git ls-files
This lists all the files that git is tracking.

---------------------------------------------
Displaying current User and Email of the repo
---------------------------------------------
git config user.name
git config user.email

---------------------------------------------
Displaying global User and Email of the repo
---------------------------------------------
git config --global user.name
git config --global user.email

--------------------------------
Getting the latest from a branch
--------------------------------
When we use the pull keyword we are fetching all the informations from the repository i.e from all the branches and multiple repo if present.
In such case its not safe to use pull keyword. what we need to do is 
1. first fetch all changes from the repo this will take all the changes  from the repository
and store it in our local .git folder but it will not merge with the file system. (git fetch origin)
2. secondly merge the prefered repo manually(git merge origin/develop)
git fetch origin
git merge origin/develop

-----------------------------
Fetch all Changes from remote
-----------------------------
git fetch --all

Adding files to Git
-------------------
git add prepares the new and existing files for staging . It adds all the new and existing file/directories to the staging area
1.git init
2.git add README.md
3.git commit -m "first commit"
4.git remote add origin git@github.build.ge.com:502643138/mv-expert-ui.git
5.git push -u origin master

List All Branches From Remote
-----------------------------
git branch --remote

GIT Fetch
---------
If a new branch is added then we need to do a git fetch so that all the branches will be copied on our m/c. i.e it will be copied to our local .git folder.
Cloning new branch
------------------
git clone git@github.build.ge.com:DataBridge/databridge.git
enter the passphase

git clone git@github.build.ge.com:SIMSDEV/sims.git
enter the passphase

Geting started with the project means getting started with the latest version of the project. But in git you have all the versions of the project from when the
project is started. This process is called cloning.
For this get the clone url from the git repository.

git clone cloneUrl
Upon success message you now have all the latest source code and you are now ready to work.


Cloning a specific branch
-------------------------
git clone git@github.build.ge.com:DataBridge/databridge.git@develop-june

Checkout
--------
git checkout sims_post_release_7_merge

To revert a code 
git checkout -- src/main/resources/log4j2.json

Deleting a branch (Develop )from local
--------------------------------------
git branch -D develop

Adding a file
-------------
git add prepares the new and existing files for staging . It adds all the new and existing file/directories to the staging area
git add filename.extension
git add .

-----------------------------------
Updating the git index while adding
-----------------------------------
git add -u
if we are doing many operation such as add, modify and delete then we can forcefully update the index of git using the command git add -u

Commit
------
//Before Commiting a set of files we need to add them. then you need to use the commit command.

git commit
git commit -m "My first Commit inline"
man git-commit
Initialize/Create a repository
------------------------------
git init - Converts the current folder into a git repository.

git init myGitFolder - Creates a folder myGitFolder and converts into a git repository.
c:\user\git\myGitFolder\.git\

Now we have created a complete repository. Means we have a .git folder and our working directory.

We also have something called bare bone repository. To create a bare repository simply pass in a flag.

git init --bare barerepo
This creates a barerepo with the git folder but does not have a working directory. Now what is the use consider this like a point of collaboration, if you drop this directory somewhere else where others can access this via secured shell you just setted up a very simple git server. you can now use that a point of colaboration to share work back and forth.


List .git folder
----------------
ls -al

List the remote git repo
------------------------
git remote -v

Git Push
---------
git push origin sims_release_7_Hotfix

Git Stash
---------
There can be situations where we need not commit few files, they may be config related or something. In such case such files need not be shown when typing git
status command.
So we stash them, where the file will be moved to a staging area.later on you can bring back from the staging location to your workspace.

git stash --adds the list of files to git staging area.
git stash pop --reverts or clears the files from the staging area to your workspace.

Know your branch
----------------
git branch
Lists all branch
----------------
git branch -a

Create New Branch in local and checkout from another branch
-----------------
git checkout -b salesorder (Created a sales order branch local repo)
git push origin salesorder (Created a sales order branch on remote repo)
git checkout -b develop origin/develop

Deleting a branch from Remote
-----------------------------
git push origin --delete branchName

git push origin --delete jpa-many-to-many-basic

Delete Branch
-------------
delete the hotfix branch
git branch -d hotfix
Deleted branch hotfix (3a0874c).

Pull from master
-----------------
git pull origin master
git pull (pulls code from current branch)

Merging from branch to master
This can be done in 2 ways.
1. From command prompt
	In command prompt its straight forward
	git pull origin master
	git push origin master
2. From GIT Web
But in Web we have a review process first then once its over we push the code to master.
Step 1 : Go to repository (https://github.build.ge.com/DataBridge/)
Step 2 : Next to the branch drop down we have a button called New Pull Request
Step 3 : Compare changes select the branch where change needs to be done. You can see the list of files changed and their changes
Step 4 : In this step you can do a code reviewing you need to select Reviewers by clicking on the settings button. if no reviewer then verify it yourself and if ok you can click on the Create Pull Request. 
Step 5 : Then you can see a message This branch has no conflicts with the base branch -> Click on the button Merge pull request.
Step 6 : Give the comment, by default the last commit message will be displayed then click the button Merge.
Step 7 : Once merging is complete you will get a message Pull request successfully merged and closed.

Another way of doing merge to master

1.Do the changes in branch salesorder
2.Push the changes to remote sales
3.check out master from local
	$ git checkout master
4.merge the branch sales order with master	in your local
	$ git merge salesorder
5.once merged then push the code to remote master
	$ git push master	
Git Stash
---------
git stash => It is equvalent to git stash push. Move the change files to temp location (stash)
This is used when we are working on one branch where we have uncommited code, then we have a requirement to work on another branch. So before checkout the new 
branch standing from our current branch we go a git stash(moves change files to a temp locaton)

git stash pop
Restores the old changes back to our branch.

git stash list
Displays when it was stashed. Or how many items are stashed.

git stash show
Displays the stashed files

Generating a new SSH key (via gitbash)
------------------------
1. Open Git Bash.
2. Paste the text below, substituting in your GitHub email address
ssh-keygen -t rsa -b 4096 -C "e.rahuljacob@gmail.com"
or
ssh-keygen -t rsa -b 4096
3.When you're prompted to "Enter a file in which to save the key," press Enter. This accepts the default file location.
Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]
4.At the prompt, type a secure passphrase. For more information, see "Working with SSH key passphrases".
enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]


Generating a new SSH key (via gitGui)
------------------------
1. Open Git UI.
2. Menu -> Help
3. On top left hand side there is generate SSH Click.
4. Upon clicking a new file will ge generated to C:\Users\1223204\.ssh folder.

How to remove files that were alredy added to GIT
-------------------------------------------------
--Make sure your .class files were not already added to the index
git rm -r --cached *.class
the files will be remived from index. then commit them. Then add to gitignore.


Creating a new branch (temp branch) from the current branch based on a commit fa1f8225cb62aa272486cbf42e3abce2b9154df1
-----------------------------------------------------
git checkout -b temp fa1f8225cb62aa272486cbf42e3abce2b9154df1

Creating a new branch(Develop) from another branch (temp)
git checkout -b develop temp

git remote -v

Merging from one branch to another (Merging of 2 branches)
----------------------------------
Consider you have one branch TASK A, and you have antoher branch say TASK B.
Now you need to merge all the code from TASK A branch to TASK B branch. do the following steps
1. once you finish your chages in TASK A branch(commit or sync with current branch or take a pull)
2. do a pull for TASK A to ensure that we have all the latest code.
3. git checkout TASK B
4. From branch B finish your task (by comitting or pushing your code with current branch or take a pull)
5. do a pull for TASK B to ensure that we have all the latest code.
6. for merging stay in TASK B branch and type git merge TASK A

Reverting a file from current branch
------------------------------------
git checkout filename
git checkout  src/main/resources/application.properties


Reverting a file or comparing a file with previous commits
----------------------------------------------------------



Viewing the changes of all files using commit id
------------------------------------------------
git show commit_id
git show fe6458761c7c15652386778e50ce34d59aa3c826


Reverting a commit in local (Make sure the data is not pushed to server)
---------------------------
1. Type git logs and check you commit is there also note your commit id and previous users commit id.
Please take the backup of your changes before giving the step 2
2. git reset --hard HEAD^
you can see the message "HEAD is now at 9e148823 created a utilty class for cover page name generation and other utilites to be used in print volume."
this HEAD at 9e148823 is your previous commit. (all your changes will be lost hence take the backup of your changes before this command)


Reverting the entire branch to a particualr commit.
---------------------------------------------------
1. Type git logs note the previous users commit id.
Please take the backup of your changes before giving the step 2
2.
git reset --hard b5beb75242d1562ea9f46fead6ab43bf042c8ef0
HEAD is now at b5beb7524 Print volume code added
3. Take latest pull to get all the codes

Reverting the local repository with the remote repository
---------------------------------------------------------
Setting your branch to exactly match the remote branch can be done in two steps:
git fetch origin
git reset --hard origin/master

**************************************************************
Configuring your email and username
-----------------------------------
$ git config --global user.name First Last
$ git config --global user.email myemail@domain.com

Listing your configuration properties
-------------------------------------
1. Lists the global properties(for all repositories)
		file location : (~/.gitconfig)
$ git config --global --list

2. Lists the local properties (particular repository)
		file location : (.git/config)
tree command
------------
 - tree command gives us a recursive directory listing.
tree .git

Initialize/Create a repository
------------------------------
git init - Converts the current folder into a git repository.

git init myGitFolder - Creates a folder myGitFolder and converts into a git repository.
c:\user\git\myGitFolder\.git\

Now we have created a complete repository. Means we have a .git folder and our working directory.

We also have something called bare bone repository. To create a bare repository simply pass in a flag.

git init --bare barerepo
This creates a barerepo with the git folder but does not have a working directory. Now what is the use consider this like a point of collaboration, if you drop this directory somewhere else where others can access this via secured shell you just setted up a very simple git server. you can now use that a point of colaboration to share work back and forth.

graph history
-------------
git log --oneline --graph
This shows all the version's of our project, The asterisks(*) and yellow line indicates all the versions of our project. And these versions are available in our local hard disk.

Git States / Checking Statuses
------------------------------
When interacting with GIT there are 4 states for a file. 
1.Untracked - Which means that file is not under control by GIT
2.Unmodified - GIT knows about the file, but it hasn't changed.
3.Modified - GIT knows about it and the file has been changed.
4.Staged - That the file is ready to commit.

git status
git add fileOne - add this file to the stage or add this to the index.
git add prepares the new and existing files for staging . It adds all the new and existing file/directories to the staging area
One file can be in multiple stages. Such as consider
1.one file fileOne is added to git repo.
2.now check the status. - you can see fileOne is in the staged row
3.now modifiy the fileOne again.
4.now check the status - you can see fileOne is present in the staged row as well as in the modified row. Means one file maintains different stage or parts.

git status -sb (summary & branch)

git config --global alias.st 'status -sb' //alias name
git st - now if i execute git st it will check the config alias.st and find it correcponds to the command 'status -sb'

Git Commit
----------
Commit - Creates a snapshot and saves to GIT History. When you are comitting you are using the index, its kind of like a workbench to put the whole parts together this is called staging area or staging changes.
git commit will take a snapshot and record all the changes into the repository
eg:Consider i have a file - file1
1. I make couple of changes to this file1 you add one line in the middle and modify an existing value. save
2. Check the status.
File is in the modified stage - nothing is in staged.
3. If i need to see the changes. then type 
git diff
4. You can see 2 hunks - hunks is nothing but all the things that are after the (2 atherate) @@ lines in the editor, after making sure the changes  i now type git status to ensure once again.
5. git add file1 - moves the unmodified file to stage
6. git status shows in green which tells us that its in stage and ready to commit.
7.git commit - now an editor is opened and it tells the status to be commited. provide the commit message and quit.
or git commit -m 'commit message'

Another quick way to commit.
----------------------------
If your modified file is not staged then type
git commit -av (all changes & verbose) this drops into my editor which shows the difference or changes to the file. I can quit by providing an empty commit message and quit. or provide the commit message and quit (wq).

man git-commit

Advance Commits
---------------
Now consider the above example where we made changes to a file by adding a new line and modifying a value. when we type git diff we see 2 hunks.
Where the first change (adding a new line) and the second change (modifying an existing line) both changes are not dependent, they are independent to each other. so we want to push this as separate commits not as a single one. In this case index will help us, the index is helps us to stage different parts of the file at different times there are too many ways.
1. command line
git add --patch
-Appears as differend hunk go to each one and type y or n. give one as y and the other as n
-Now type git status you can see one fileOne in the staged and the same fileOne in modified too.
-Now to understand better type git commit -v (verify)
-Give the comment and exit.
Now type git status
-Give you can see the file is in the modified area
Now type git commit -av

2.On GUI
Open git gui go to the hunk and right click Stage Hunk for Commit. then this change will move to stage.
Now one commit this file with the message
Now we have only the remaining one hunk, double click and move it to stage
And commit with a message.

GIT Hosting:
------------
In order to work with other people you need to put the code so that others can also access them. This is generally called Git Hosting.
There are several ways to accomplish it.
1.SSH
a.Best with Linux Server
b.Need to have a git user account
c.Each user should create a SSH Key
d.SSH in and create repository
e.git@servername:project.git
f.git-shell
Pros
a.Free
b.No specific s/w or h/w we already have everything.
c.Very secure
Cons
a.GIT only
b.Highly technical not user freiendly
c.Many steps 
d.audit control is difficult.
e.No auditing
2.Internet Hosting
a.GitHub,GitLab,Bigbucket
b.Easy administration
c.Easy Project management
d.Accessable for non-technical
e.Access over HTTPS
f.Extra
	Issue Tracking
	code review
	documentation.
	pull request.
3.On-Premises hosting
a.Runs on your machine
b.Runs inside your n/want
c.Github Enterprise,Stash, GitLab
d.Equivalent to Internet Services.


Remote Repositories:
--------------------




	




Writing a file
--------------
echo "Test Git Quick Start demo" >> start.txt
This will write the content into a new file start.txt

-----------------
Displaying a file
-----------------
cat start.txt
This is display the contents of the file start.txt
----------------------------------------------------
Installing a Text Editor and configure to Git
----------------------------------------------------
Now we will configure the Notepad++ with Git so that we can run with command environment.
1. Open git bash and type 
$ notepad++
if we get an error notepad++ command not found then we need to install it.
2. Exit gitbash
3. Find where is notepad++ installed and copy the path i.e C:\Program Files\Notepad++
4. Copy the path to our environment variable path just like we did for java and all.
5. Open a new git bash and type
$ notepad++
And it opens.

----------------------------------------------------------------------
Provide Alias to notepad++ as npp and open a new instance of notepad++
----------------------------------------------------------------------
Its always recommended to create the file in user's home directory.
1. Open git bash
2. Type notepad++ .bash_profile
and press enter.
3. Notepad++ will prompt to confirm whether the new file should be created.
4. Type 
alias npp='notepad++.exe -multiInst -nosession'
Save and close the file.
5.close gitbash
6.open a new gitbash and type npp
The notepad++ is opened.

--------------------------------------------------
How to configure notepad++ as default text editor
--------------------------------------------------
1. Open gitbash
2. And lets view the current global config which are present
$ cat ~/.gitconfig
Press Enter. The symbol tild '~' denotes user's home directory.
3. now we use the git config command to make notepad++ as our default text editor
$ git config --global core.editor "notepad++.exe -multiInst -nosession"
Press Enter.
4. Verify the newly added property in the config file
$ git config --global --list
5. Now we will test whether it works so we will try to open the config file in edit mode
$ git config --global -e
Press Enter and the config file opens in notepad++

--------------------------------------------------------------------------------------
Adding the file and commiting the file in one step (Express Commit/Stream line commit)
--------------------------------------------------------------------------------------
A tracked file is a file which git is tracking actively. i.e any file that is commited or added to staging area. This is also called as Express Commit.
git commit -am "Commiting Files As Per the Defect In Rally"

----------------------------------------
To find whether a file is tracked or not
----------------------------------------
git ls-files
Identifying the tracked file
	- Add a new file to the repo (xyz.txt)
	- type the command $ git status and you can see xyz.txt is untracked.
	- also type git ls-files (the file xyz.txt won't be listed)
	- type git add xyz.txt
	- git status now the file will be tracked and its a new file.
	- also type git ls-files (the file xyz.txt will be listed)
	

One of the advantages of staging areas is we build up our files for commit. i.e we only want to use the -a parameter in the commit command when we dont want to add any changes to that commit, we make it simple and straing forward edit to an existing file. when we have a change that will expand multiple file then we definitely want to use the staging area.

-------------------------
Adding files recursively
-------------------------
git add .

-----------------------------------
Updating the git index while adding
-----------------------------------
git add -u
if we are doing many operation such as add, modify and delete then we can forcefully update the index of git using the command git add -u

--------------------------------
Backout Changes (Revert Changes)
--------------------------------
a) From Staged to Unstage (Changes done to the file will be present only thing is the file will be moved from staged to unstage area)
git reset HEAD filename.txt
Now if i type git status, i can see the file has moved from stage to unstaged area

b) To revert latest from repo(I dont want my changes in the file i.e i just want the state of the file that is last commited)
git checkout -- filename.txt
Now if i type git status i can see the file is not there in unstaged or staged area. since i have reverted the file to its last commit there is not changes hence it won't be listed. So now we have the lastest file that was last comitted.

-------------------------
Renaming or moving a file
-------------------------
We can do a delete or move operation in 2 ways 
1. Either using git mv or rm command
2. Or by using any file manager s/w that is associated with operating system

a) Renaming a file using git
git mv current_filename.txt new_filename.txt

git mv file-level3.txt level3.txt
Now if i do a ls
level3.txt
Now if i do a git status i can see that git has already understood a rename has taken place and the file is now in staged area but its not commited means i can also backout if needed.

b) Renaming the file at operating system level with out using git.
mv current_filename.txt new_filename.txt

mv file-level3.txt level3.txt
Now if i do a ls
level3.txt
Now if i do a git status git sees it as 2 operations
1. It see's that you deleted the old file (staged area)
2. And added a old file. (untracked file)
So now we need to add the file, since we have done this outside our git environment, we use add command with an extra parameter.
	git add -A
	the option -A will add any files that is recursively changed but also it will update any files that is renamed, moved or deleted in the working directory
Now if i do a git status i can see that git has already understood a rename took place and the file is now in staged area and its not comitted.

c) Rename a file and backing it out.
	- git mv file-level3.txt level3.txt
	- ls => level3.txt
	- git status => file in staging area
	- now if we want to backout we can either use git reset HEAD level3.txt or we have an easier approach git mv level3.txt file-level3.txt
	- now if i type git status i can see a clean working directory, git tells us that there is no change.
	
d) Move the file to another directory
Moving a file from one level/folder to another level/folder
git currentfile.txt newpath
Now currentfile.txt will be moved from current directory to newpath directory

git level2.txt dirlevel3
now if we do ls we cannot see the file level2.tx
we go up a level/folder cd dirlevel3
type ls
we can see the file level2.txt
Now if we type git status we can see that git has already staged the file and git understands that a move operation has taken place and its not comitted.

e) Move the file to another directory with out using git
mv file-level3.txt level3.txt
Now if i do a ls
level3.txt
Now if i do a git status git sees it as 2 operations
1. It see's that you deleted the old file (staged area)
2. And added a old file. (untracked file)
So now we need to add the file, since we have done this outside our git environment, we use add command with an extra parameter.
	git add -A
	the option -A will add any files that is recursively changed but also it will update any files that is renamed, moved or deleted in the working directory
Now if i do a git status i can see that git has already understood a rename took place and the file is now in staged area and its not comitted.

--------------
Deleting Files
--------------
a) Deleting an untracked file
We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt
 - Now id i want to delete this by using the git rm command
 - git rm doomed.txt -> git will complain that doomed.txt didn't match any files, this is because its untracked file. so we need to use the operating system's delete functionality for deleting the file.
 - rm doomed.txt
 - if i do a ls the file is gone, if i do a status i have a clean working directory.
 
b) Deleting an tracked file
We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt 
 - Add the file git add doomed.txt
 - Now type status  we can see doomed.txt is not added to staging area commit the file.
 - Now type git ls -files towards the bottom we can see doomed.txt
 - Now one way to delete the file tracked by git is by using the git rm command, git rm filename.txt
 - git rm doomed.txt
 - now if we type ls command we can see that the file doomed.txt is not listed in the directory
 - now if we type status git has staged the file by identifying it as deletion operation has taken place and is not comitted.
 
c) Backing out a deleted file from staged area. 
 We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt 
 - Add the file git add doomed.txt
 - Now type status  we can see doomed.txt is not added to staging area commit the file.
 - Now type git ls -files towards the bottom we can see doomed.txt
 - Now one way to delete the file tracked by git is by using the git rm command, git rm filename.txt
 - git rm doomed.txt
 - now if we type ls command we can see that the file doomed.txt is not listed in the directory
 - now if we type status git has staged the file by identifying it as deletion operation has taken place and is not comitted.
 - Now we need to revert it so we type the reset HEAD command
 - git reset HEAD doomed.txt
 - Now if we type the ls command we cannot see the file doomed.txt yet 
 - Now if we type git status the file doomed.txt is still in the untracked list. so what did the reset HEAD command do it moved the file from the staging area to the untracked area.
 - Now we need to checkout the doomed.txt command.
 - Now if we type ls we can see the doomed.txt file in the directory
 - Now if i do a git status now it shows us a clear working directory.
 
d) Deleting an tracked file with out using git
We will create a simple file named doomed.txt and add some contents.
 - Now if i type git status i can see one untracked file doomed.txt 
 - Add the file git add doomed.txt
 - Now type status  we can see doomed.txt is not added to staging area commit the file.
 - Now type git ls -files towards the bottom we can see doomed.txt
 - Another way to delete the file tracked by git is by using the rm command i.e with out using the git as prefix, rm filename.txt
 - now id i type ls i cannot see the file in the directory
 - if i type git status i can see the file is deleted and its in the staging area.
 - git add -A
 the option -A will add any files that is recursively changed but also it will update any files that is renamed, moved or deleted in the working directory
 - Now if i do a git status git now has the files staged.
 

History/Log
-----------
To view the git history type the command 
$ git log

We can understand more about by log command by typing the help command
$ git help log
It has several options and we will explore a few

$ git log
Displays the default view in reverse cronological order, i.e starts with the last commit.
Following informations are available 
1. commit followed by a long string (shaawvan). This long string is a unique identifier that tells git about every commit.
2. Next we have the author and email id.
3. Next is the date when the commit happened.
4. Next the commit message.

If we want the commit id's (shaawvan) to be shortened then
$ git log --abbrev-commit
In this the commit id is shortened it consist of 6 charaters which will help us to identify a commit.

One liner
$ git log --oneline

Now we will try another option
$ git log --oneline --graph --decorate
--online   : What this will do is it will compress all the information in one line.
--graph    : What this will do is provide an ascii graph depicting the branching graph
--decorate : Will add any labels or tags or any thing that sort of annotates our commits.

Another way to view the logs is by providing a range of commit ids
$ git log ae6f872...761b911

Another view is to display logs based on dates
$ git log --since="3 days ago"

Now lets view the commit history for an independent file
$ git log -- filename.txt
return's the commit for only specific file.

Git show command
----------------
$ git show commit_id;
Displays the given commit information
Following informations are available 
1. commit followed by a long string (shaawvan). This long string is a unique identifier that tells git about every commit.
2. Next we have the author and email id.
3. Next is the date when the commit happened.
4. Next the commit message.
5. And the difference basically what has changed.

----------
Git Alias
----------
How to add aliases in git
For eg: we have a big git command such as
	$ git log --all --graph --decorate --oneline
We can view a neat log history of all my commits in the git repository. But involves a lot of writing to be done for this display. So what i can do is i can write my own command that is an alias which will give me the exact same output but with a shorter command.

So to add an alias 'hist'
First i type git hist to check we have a existing command 'hist' in git. if i get an error git : 'hist' is not a git command then we can go ahead with this alias 'hist'
To create my own hist command i need to piggy back half of git config command. So i need to type
$ git config --global alias.hist "log --all --graph --decorate --oneline"
where --global -> we need the alias to be available regardless of our repository so that will be saved at the user level. 
	  alias -> any configuration setting that starts with alias dot allows us to create a command.
	  command -> We provide the full command in double quotes that i want to be issued leaving out the git keyword so in this case we just start with 
				"log --all --graph --decorate --oneline"
				double check the command and press Enter.
				
Now try the command
$ git hist
If the output is displayed then we added a new command in git as alias.

Where the aliases are Stored
-----------------------------
If we know where aliases are stored we can modify the command when needed. And since we are using git's config command we need to open the .gitconfig file in the user's home directory.
npp ~/.gitconfig
This opens the gitconfig file and all our aliases will be in the aliase section of git config file. we can see the name of the command hist and the full command.
We can modify save and re-run the $ git hist command to view the latest saved information.

------------------------------------------------
Ignoring Unwanted Files and Folders (.gitignore)
------------------------------------------------
In order to avoid Unwanted files and folders we use the facility of a text file called .gitignore. This .gitignore tracks all the files and folders that git should ignore.

In order to check whether a .gitignore file is present we use the command
	ls -al
	This lists all the hidden files in the directory.
However the .gitignore file should be present in the same level of .git folder.

If the file is not present the we can create a new file with the name '.gitignore'
Now the format of '.gitignore' is 
1. One expression per line.
2. The expression can be name of a specific file
3. The expression can be a name of the folder.
4. The expression can be a pattern like *.txt

a) As of now we will add a specific file, open '.gitignore' file and type
.DS_Store
Save and type git status, we can see the earlier file .DS_Store is not present in the untracked file. and the .gitignore file is modified or is untracked.
The .gitingore file is like any other ordinary file that need to be added to the version controller.
$ git add .gitignore

b) Now we will add a pattern *.log, open '.gitignore' file and type
*.log
So any file that ends with a .log will be captured by this inspection.
Type git status and we can see that the *.log file is not there in the untracked file where as the file .gitignore is modified.

c) Another scenario is a folder, open '.gitignore' file and type
log

----------------
cleanup and Push
----------------
Sometimes when we type git status we can see a message 'Your branch is ahead of origin/master by 14 commits' means we have 14 commits on our local branch but it not there in remote branch. Its time for us to synchronize remote and local. So before pushing its best practice to first take a pull first then push the code.
$ git pull origin master

Now to push the code
$ git push origin master
where origin refers to the name of the remote repository that we have given in this repository. It refers back to the github repository and master is the default branch.

--------------------------------------------
Configuring Merge Tool and Diff Tool for Git
--------------------------------------------
We can use any merge or diff tool with Git. In the demo we have seen how to configure P4Merge, since i am using WinMerge or ExamDiff we will configure these as the default merge or diff tool for Git.

Now we will configure the WinMergeU with Git so that we can run with command environment.
1. Open git bash and type 
$ WinMergeU
if we get an error WinMergeU command not found then we need to install it.
2. Exit gitbash
3. Find where is WinMergeU installed and copy the path i.e C:\Program Files (x86)\WinMerge
4. Copy the path to our environment variable path just like we did for java and all.
5. Open a new git bash and type
$ WinMergeU
And it opens.
Merge Tool
----------
git config --global merge.tool winmerge
git config --global mergetool.winmerge.path "C:/Program Files (x86)/WinMerge/WinMergeU.exe"

Note : With respece to windows we use backslash for specifying file paths but here we need to use forward slash for configuring paths in GIT.

Disable Prompt
git config --global mergetool.prompt false

Diff Tool
---------
git config --global diff.tool winmerge
git config --global difftool.winmerge.path "C:/Program Files (x86)/WinMerge/WinMergeU.exe"

Note : With respece to windows we use backslash for specifying file paths but here we need to use forward slash for configuring paths in GIT.

Disable Prompt
git config --global difftool.prompt false

git config --global -e


--------------------------------
+ Understand Comparison's in GIT
--------------------------------
To understand comparison's we have different scenario's. As a part of the tutorial we will first create a file in all the 4 stages or level in GIT such as
1. Working Area
2. Staged Area
3. Local repo
4. Remote repo

a)For this we create a file called README.md, add the following
--------------------------------------------------------------- 
# Starter Web Project
	
## Introduction

## Purpose

## Deployment

## How To Contribute

 - Add the file to GIT $ git add .
 - Commit the file $ git commit -m "Initial File"
 - Push the file $ git push origin master
Now we have added the file to remote. 
b)Modify the README.md and push
-------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	
## Purpose
	
## Deployment
	
## How To Contribute	
 - Do a Express Commit the file $ git commit -am "Added Description"
 - Push the file $ git push origin master

c)Modify the README.md
----------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	
## Purpose
	
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
## How To Contribute	
 - Do a Express Commit the file $ git commit -am "Added Description"
 - Push the file $ git push origin master 
Now we have modified the file in the remote.

d)Modify the README.md and commit
---------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
 - Do a Express Commit the file $ git commit -am "Added Introduction" 	
Now we have modified the file and commited. So the file is present in our local git repo.

e)Modify the README.md and commit
---------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
	If you like the content don't forget to subscribe and like also don't forget to click the bell icon.
 - Do a Express Commit the file $ git commit -am "Added Purpose" Contribution to help.txt" 	
Now we have modified the file and commited. So the file is present in our local git repo.

f)Modify the README.md and add it but don't commit it
-----------------------------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	Tutorial for comman layman to understand git and github. (Staged)
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
	If you like the content don't forget to subscribe and like also don't forget to click the bell icon.
 - Now Add the file.	
Now we have modified the file added. So the file is present in our staging area.

g)Modify the README.md and dont add it don't commit it
------------------------------------------------------
# Starter Web Project
	This is a sample file for showing the git operations using command line.
## Introduction
	This is a sample code to understand commands in GIT
## Purpose
	Tutorial for comman layman to understand git and github. (Staged)
## Deployment
	This activity is an automated process which will be done at 1:00am every day.
	
## How To Contribute
	If you like the content don't forget to subscribe and like also don't forget to click the bell icon.
	
## Feedbacks
	Provide your feedbacks at githubtraining@git.com (Un-staged / Working directory)
 
Now we have modified the file but not yet added. So the file is present in our git's working area.

Comparison Exercise's
---------------------
1)Comparing Changes b/w unstaged and staged
--------------------------------------------
$ git diff
When we type the git diff all the files in the git's working area or unstaged area versus staged area are displayed. If there are three files in the unstaged area then all the 3 files will be listed.

Limiting comparison's to one file
---------------------------------
So In our example if i want to limit only the README.md file then i need to write
$ git diff -- README.md

The same can be viewed using WinMerge which is our default Git difftool
$ git difftool -- README.md
In this scenari the file will be opened in winmerge where we have one file from the local and another file from the actual repository path.


Note
/******************************/
git diff

Shows the changes between the working directory and the index. This shows what has been changed, but is not staged for a commit.

git diff --cached
git diff --cached origin/branch1 (staged Vs remote)
git diff -R --cached origin/branch1 (remote Vs staged) -R option is to reverse the difference.

Shows the changes between the index and the HEAD (which is the last commit on this branch). This shows what has been added to the index and staged for a commit.

git diff HEAD

Shows all the changes between the working directory and HEAD (which includes changes in the index). This shows all the changes since the last commit, whether or not they have been staged for commit or not.
/*********************************/


2)Comparison between commits
----------------------------
Now we have taken the README.md file as example

$ git log
xyz123 File Added
awer11 Description added
l3l3o3 Copyrite added
159822 removed spelling check


we can see the list of commit id's. Now if we want to compare 2 commits then
$ git diff reference1 reference2
$ git diff 1313o3 HEAD
where the pointer HEAD points to the last commit in the cureent branch.
Now if you press Enter you can see all the changes that have happened of several files from the last commit to the specified commit.

Alternative syntax.
-------------------
$ git diff HEAD HEAD^
This compares HEAD and HEAD - 1.

The same can be viewed using WinMerge which is our default Git difftool
$ git difftool HEAD HEAD^
i.e we can now visually see the difference between the last commit of the branch verses the commit just prior to the last commit in the branch.

Now i am taking 2 reference commits
$ git diff 159822 awerll
Now we can see the differneces b/w the one side and the other. There are cases where reference exists by dev/null which indicates the file has not exists prior and the other side the file exists.
For eg:
---------------------
--- /dev/null
+++ b/hipster.txt
---------------------
The above line indicates that the file is new.

The same can be viewed using WinMerge which is our default Git difftool
$ git difftool 159822 awerll
In difftool we can see only one file at a time, close the first then we can see the other.

3)Comparison between local and remote master branches
-----------------------------------------------------
Now we are going to compare between local repository branch and remote repository branch.
Syntax is
$ git diff rightsidecompare Vs leftsidecompare

$ git diff master origin/master
where origin is the name of the remote reference thats points to github and master is the branch on the git repository
  and master is the local repository which is pointing to head.
  
To view this visually
---------------------
git difftool master origin/master

-----------------------
+ Branching and Merging
-----------------------

1. Introduction
---------------
As of now we are doing all our changes in the master, which is not a best practice. What we should be doing is separating our changes into branches which makes sence. At the simplest level we should be atleast be creating a feature branches or topic branches to isolate our changes and then integrate them back to the master branch once this feature or topic is stabilized or completed.

To start of branches we will start with the listing of branch
Listing of Branches
-------------------
$ git branch
This will list down all the local branches on the m/c.

$ git branch -a
where -a list's both the local and remote branches, and the git branch command will put an asterisk(*) on the current active branch.
there is a color coding
	green -> current active
	red -> all remote branch
	gray -> locally repository branches available
	
Creating a new branch
---------------------
$ git branch branchName
where branchName is the name of the new branch
eg $ git branch mynewbranch

Now if i try listing the branch git branch -a, i can see the newly added branch mynewbranch added in the local repository.

Switch branches
---------------
To switch from one branch to another we use the git checkout command
$ git checkout branchName
here branchName is the name of the branch that you need to switch.
eg: git checkout mynewbranch
Now if you type git branch -a, you can see that the asterisk(*) is not moved to the new branch mynewbranch.

Alternative Approach
--------------------
Another way to creating a new branch and switching it to the newly added branch is by using the below command
$ git checkout -b branchName
where branchName is the name of the new branch
 -b helps us to branch or switch to the newly created branch.
Now you are in the newly created branch. Where as if you are not using -b then you will still be in the current branch you won't be switching to the newly created branch.
	
Now lets see how this is displayed in the history or logs
---------------------------------------------------------
$ git log --oneline --decorate
e060e24 (HEAD, origin/master, origin/HEAD, mynewbranch,master)
You will see something interesting here, the first commit which is our last commit has several labels associated with it. So we have HEAD which always points to the last commit on the current branch. origin/master, origin/HEAD, mynewbranch and master. So HEAD and origin/HEAD are simple pointers to the last commit on the respective branches both local and then remote. master is the branch which we are working with all along and the mynewbranch is the branch we just created.
Since we haven't made any changes yet all the branch labels are pointing to the same commit. Thats because branches are just labels or pointers. Our new branch wont actually branch off as we say until we have new commits that are unique from master. i.e the prompt updated with the newly created branch name.

Renaming a branch
-----------------
$ git branch -m mynewbranch newbranch
where -m is move.
Now we modified the branch name from mynewbranch to newbranch.
Now if we type git branch -a
We can see that mynewbranch is renamed to newbranch.

List All Branches From Remote
-----------------------------
git branch --remote

Delete a branch
---------------
If we no longer need a branch
$ git branch -d branchName
where branchName is the name of the branch that is to be deleted.
We cannot delete a branch in which we are currently on. you need to switch to another branch to delete it.
Now if we type git branch -a, we can see that our branch no longer exits.

Another Approach
----------------
If we try to delete the branch by giving the below command
$ git branch -d branchname
We may sometimes get an error as shown below
error: The branch 'ppd_common_feature' is not fully merged.
If you are sure you want to delete it, run 'git branch -D ppd_common_feature'.

Then we need to provide -D option

$ git branch -D branchname

eg
$ git branch -D ppd_common_feature
Deleted branch ppd_common_feature (was 2d7589e).

2. Fast Forward (Happy Path)
----------------------------
Now let's start some branching and merging examples.

1. go to the repository
2. type $ git branch -a
3. create a new branch title-change
$ git checkout -b title-change
4. modify the html file.
	Change Title
	Change Body
5. type git status and we can see the html file is modified.
6. do an express commit 
$ git commit -am "simple.html file changed"
7. check the log
$ git log --oneline
8. Perform Merging
We can see our commit at the top. So we have currently commited a change in the title-change branch and we need to move it into master.
First thing we need to do is 
a) Change back to master branch
$ git checkout master
Before i do a merge i need to know the differences are.
$ git diff master title-change
Now we can see the differences b/w the branch, if we need to see it visually then git difftool master title-change
Now after reviewing we do the merege
b) To do the merge we use the merge command
$ git merge title-change
Doing so git will respond to the merge 
	1.Updating 
	2.Hashes or commit id
	3.Fast-forward - It tells that the merge is a fastforwarded one
	4.simple.html - the files involved in the merge
	5.Status - deleted or inserted count.

Since this was a fast forwarded merge, effectively what just happened was Git just placed all the commits on the master branch as if we never branch away.
Fast forwarding is only really possible when there are no changes being made in the target branch, which is what we just did. We created a branch did some changes and we merged back. we didn't do any additional work in the master or target branch before doing the merge.

9. Now we view the log
$ git log --oneline --graph --decorate
Now we can see the HEAD is pointing to the lastest commit on the current branch. And the title-change and master is also pointing to the same commit as well. 
10. Delete the branch
Now if we list our branches 
$ git branch
Now we can see 2 branches master and title-change, since we have already merged the title-change to our master we no longer need it so to delete the branch we type the command
$ git branch -d title-change
Now if we type git branch we can see only the master branch.
11. Now we view the log
Now if we type git log
git log --oneline --graph --decorate
At the top commit we can see only the master branch. the title-change is removed.

3. Disable Fast forward Merge (Happy path without fast forward)
---------------------------------------------------------------
We need to be in a clear working directory. Once typeed 
git branch
we can see only the master branch.

1. Now lets us create a branch add-copyright
$ git checkout -b add-copyright
Now the branch has been created and we have switched into it.
If we type git branch 
we can see the newly created branch add-copyright and an asterisk against it.

2. Lets modify the file by adding a copyright details and the start and end of the html file.
Save the file.

3. Now check the status by
$ git status

4. Now we commit the file
$ git commit -am "Adding copy right information"

5. Now we also modify the README.md file
Save the file

6. Now we commit the file 
$ git commit -am "Adding copyright info to README.md file"
Now we have 2 files commited in the add-copyright branch.

7. Now if we check our logs
$ git log --oneline --decorate --graph
Now you can see the copyright information at the top. Press q to exit and lets integrate the changes to our master branch.

8. For that first switch to Master branch from add-copyright branch
$ git checkout master

9. For Merging the add-copyright branch to master type the code
Now this time i want to preserve the fact that we branched off so i am going to disable the fast forwarding capability by specifying the --no-ff option
	$ git merge add-copyright --no-ff
Now when we press enter its going to do a merge commit. So we end up with a commit message which the editor displays as 'Merge branch add-copyright'. So now we want to save and close.
We get the below message
Merge made by the 'recursive' strategy.
 index.html | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

10. Now we check the log
$ git log --oneline --decorate --graph
Now if we look at the logs we can see the graph line being preserved.
11. Delete the brach
Now we have integrated the changes now we can get rid of the branch
$ git branch -d add-copyright

12. Now if we view the log
$ git log --oneline --graph --decorate
we can see that the we don't have the label's or branch-name associated when we branch off. i.e the branching still occurs but we don't have a label associated that's all.

4. Automatic Merges
-------------------
So Now we have covered how to create a branch, do some work on it and merge it into master. But in the happy path scenario where the result is a fast forward merge, even going as far as to disable the fast forward merge scenario but we still have that condition present. So the next step is to go through the process but this time there will be an automatic merge and result in a merge commit automatically.

We need to be in a clear working directory. Once typeed 
git branch
we can see only the master branch.
1. Now lets us create a branch simple-changes
$ git checkout -b simple-changes
Now the branch has been created and we have switched into it.
If we type git branch 
we can see the newly created branch add-copyright and an asterisk against it.

2.Now lets edit first file that is independent of each other.
 - make changes for file1
 git status we can see file1 is modified.

3. Commit the file
 git commit -am "File Modified 1 in simple-changes branch"

4.Now lets edit second file that is independent of each other.
 - make changes for file2
 git status we can see file1 is modified.

5. Commit the file
 git commit -am "File Modified 2 in simple-changes branch"

6. For that first switch to Master branch from add-copyright branch
$ git checkout master 

7. Before merging the changes in i am going to make change to a file in the master. This could be done by another developer or you can do the change by context switching (branch switching) so lets update the README.md file (Note that you should change a file which you have not updated in the simple-changes branch....)
Save the file and type git status, we have one modified file.

8.Now the commit the file in master branch
$ git commit -am "Commiting file info master branch"

9. Now if we view the log
$ git log --oneline --decorate --graph
You can see an interesting thing in the top of the log, we have a commit on the simple changes that is different and we have a commit on the master.

10. Now Merge the code from simple-changes to master
So from master, we do the merge
$ git merge simple-changes -m "Merging changes from simple-changes to master"
 where -m is the message.
Since we know that this merge results in a commit so in quotes we give the commit message.
Then you get the below text as response from git
Merge made by the 'recursive' strategy.
 help.txt   | 2 ++
 index.html | 4 ++--
 2 files changed, 4 insertions(+), 2 deletions(-)

11 Repeat the git log command
$ git log --oneline --decorate --graph --all
So if you notice the top log, so we can see that when the merge happended. that we have the merge commit and the simple-changes is still preserved as a separate branch. 

12. Now we have integrated the changes now we can get rid of the branch
$ git branch -d simple-changes

13. Now if we view the log
$ git log --oneline --graph --decorate
we can see that the we don't have the label's or branch-name associated when we branch off. i.e the branching still occurs but we don't have a label associated that's all.

14. Now we check and ensure that our file changes are present.

5. Conflicting Merges and Resolution
------------------------------------
Now we will understand and resolve merge confilicts.
Most of the times you will be doing a fast forward merge or merges that could result in fast forward or GIT is going to resolve the merges automatically. However sometimes you are going to run into conflicts and you are going to need to resolve them. lets see with an example.

We need to be in a clear working directory. Once typeed 
git branch
we can see only the master branch.

Now we are going to modify the simple.html file on one branch switch back to master and do similar change in the same file simple.html and that too in the same area's. So that it will result in a conflict. 

Perhaps this can occur if two different developers working on different branches and they have to come together and there changes are not yet compatable. Somebody has to sit and work down the issues.

1. Now lets us create a branch real-work
$ git checkout -b real-work
Now the branch has been created and we have switched into it.
If we type git branch 
we can see the newly created branch real-work and an asterisk against it.

2.Now lets edit the simple.html file
 	- body of the page
	- footer
	- title
	- paragraph
and save.
Now if we type git status we can see that simple.html is now modified.
3. Commit the file
$ git commit -am "Making changes to simple.html in real-work branch"
if we type git status we have a clean working directory.

4. Now we switch to master
$ git checkout master

5. Now we edit the same file simple.html, Now lets create some changes for conflicting with the other branch.
 	- body of the page
	- footer
	- title
	- paragraph
and save.
Now if we type git status we can see that simple.html is now modified.

6. Now the commit the file in master branch
$ git add simple.html
$ git commit
Now it invokes the editor and i type in the message  "Commiting file info master branch"

7. View the logs
$ git log --oneline --decorate --graph --allows
Now git shows that our work is diverged we have real-work and master with different changes. 

8. Compare the files in both the branch using difftool or diff
$ git diff master real-work 
Now when we compare we can view the changes in the same line hence we can assure that conflict occurs.
To view the changes visually
$ git difftool master real-work
And we can visually inspect the changes between the two branches.

9. Now Merge the code from real-work to master
So from master, we do the merge
$ git merge real-work
When we press enter we get a merge conflict error the branch name changes from master to master|MERGING
Following are the output results that git displays as a part of merge
1. Auto-merging simple.html
	GIT first tried to do a auto-merge
2. CONFLICT (content): Merge conflict in simple.html
	GIT couldn't do the auto-merging so it resulted in a conflict in the content.
3. Automatic merge failed : fix conflict and the commit the result
	So Automatic merge Failed, so now we have to fix the conflict's 
4. (merge|MERGING)
	So we are merging against the master so we are in a MERGING state or neither in a clean working directory or in a staged area or in between state of merging.
10. Open the conflicted file simple.html and manually merge the changes
We can see some extra tags such as HEAD and real-work which is the branch name. This is nothing but Git will markup or show up or highlight the differences. So in simple.html the difference's are marked as follows
/****************************************************************************************/	
A. Difference at Area 1
<<<<<<< HEAD
	<title>A Very Respectful Website</title>
=======	
	<title>A Great Website</title>
>>>>>>> real-work

B. Difference at Area 2
	<p>
<<<<<<< HEAD
	I'm not sure what will go here but i am sure it will be nice
	</p>
  </main>
  <footer class="container">
	<p>&copy; 2002 github.com</p>
=======
	Some interesting stuff goes here
	</p>
  </main>
  <footer class="container">
	<p>@copy; 2020 github.com</p> 
>>>>>>> real-work

C. Difference at Area 3



/****************************************************************************************/
So if we look at the first difference 

<<<<<<< HEAD
	<title>A Very Respectful Website</title>
=======		
Here HEAD is referencing to the target branch which is master, because we did a merge from the target branch which is our master branch. Here the contents are of simple.html present in master branch.

and 

=======	
	<title>A Great Website</title>
>>>>>>> real-work
Here real-work is the new branch and the contents are of the simple.html presetn in real-work branch.	

If the changes are simple then we can modify the files manullay merge the conflict and proceed.

11. Open the conflicted file simple.html using mergetool and manually merge the changes
Open the mergetool which we configured by providing the comman
$ git mergetool
This opens the file in diffmerge and merge it manually.

There are 3 files now out of which 3 are created by git and one is our main simple.html file in which we should resolve the conflict.
1) ./simple.html.REMOTE.4937.html
2) ./simple.html.BASE.4937.html
3) ./simple.html.LOCAL.4937.html

Now where we have to manually pick and choose the respective content. Once done save and close the file.

12. Check the status.
Before merging the changes our brnach or prompt is in the (master|MERGING) state. So if we type
$ git status
	- The branch is master and its in the merging state (master|MERGING)
	- We can see that the simple.html is modified and its in ready to be staged state.

13. Commit the merged File simple.html
Till now the status of the branch or prompt is (master|MERGING) and we have manually merged the file and now we need to do a commit. For that type the commit command
$ git commit -m "Done resolving merge conflict"
Once i have done the commit my prompt or branch stage has changed from (master|MERGING) to (master), which means i am out of the merge conflict.

Note if i do a git status i can see one un-tracked file named simple.html.orig and thats because resolving the merge git will save of an original copy of the merge conflicts so that something got lost we can revert the changes. However i don't want to track the *.orig files so that we can go and add it in the .gitignore list now if we do a git status we can no longer see the *.orig file. Now we commit the .gitignore file.

14. Delete the real-work branch
Now we have integrated the changes now we can get rid of the branch
$ git branch -d real-work

15 View the Log
$ git log --oneline --decorate --graph --all
I can see that i have done resolving merge conflicts, which is a merge commit. followed by the latest commit which i did for commiting .gitignore file to exclude the *.orig files.

-----------
+ Rebasing
-----------

1. Simple Rebase Example
------------------------
In order to understand the concept of rebasing. We have to do some steps.
1. From the master bracnch creature a feature branch.
2. And in the feature branch do some work atleast 3 commits.
3. Later on switch back to master and do some work atleast 3 commits.
4. And rebase my changes back to the feature branch.

So consider we have a master branch 'rebase-master' and feature branch called 'rebase-test'
1. We switch to 'rebase-test' 
$ git checkout rebase-test.
2. We add server.port in application.properties file 
## Added Server Port 
#server.port=8009
3. Then we do a express commit
$ git commit -am "server.port added to application.properties"
4. We again add logging.file in application.properties
## Added Log File
#logging.file=springbootdemo.log
5. Then we do a express commit
$ git commit -am "logging.file added to application.properties"
6. Now we switch to master branch
$ git checkout rebase-master
7. Now we will modifiy the pom.xml by adding some comments
Add the comment for maven-plugin
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-maven-plugin -->
8. Then do a express commit
$ git commit -am "Comment added for maven-plugin in pom.xml"
8. Now again we will modifiy the pom.xml by adding another comments
Add the comment for springboot-web
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web -->
9. Then do a express commit
$ git commit -am "Comment added for springboot-starter-web in pom.xml"
10.Let take a look at our history
$ git log --oneline --decorate --all --graph
/********************************************************************************************/
* 536dfa5 (HEAD -> master-rebase) comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
| * 5a3cc62 (rebase-test) logging.file configuration added in application.properties
| * b5e9d0e server.port configuration added in application.properties
/********************************************************************************************/
Now you can see in the above, o/p you can see the master-rebase and rebase-test they are in separate lines and you can see the graph line diverging. So in a rebasing scenario i am not done with my feature but i want to incorporate any changes that may have happened on master. so i will have a massive headache when i do merge later. so to do that i can use rebase. So i want to rebase master (master-rebase) into my feature branch (rebase-test). 
11. So i am returning to feature branch 
$ git checkout rebase-test
Now that i am in rebase-test feature branch lets rebase in any changes that we have made on the master branch and then lets see how it has effected our history.
12. Git Rebase Command
lets use the git rebase command and on the branch in which you want to do a rebase into we type
syntax : git rebase source-branch
eg: git rebase feature
$ git rebase master-rebase
/********************************************************************************************/
First, rewinding head to replay your work on top of it...
Applying: server.port configuration added in application.properties
Applying: logging.file configuration added in application.properties
/********************************************************************************************/
So the rebase command is saying its rewinding our head which is our current branch so that we can reapply any changes we have made on top of what every has happened on master.
So finally what every changes in master i.e changes in the pom.xml will be taken and then our changes related to application.properties will be addded on top of it. Hence its says first rewinding head to replay your work on top of it.
13.Let take a look at our history
$ git log --oneline --all --decorate --graph
/********************************************************************************************/
* 496b09d (HEAD -> rebase-test) logging.file configuration added in application.properties
* 158b30e server.port configuration added in application.properties
* 536dfa5 (master-rebase) comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
| * baa6a97 (origin/master, master) modified source
/********************************************************************************************/
Now you can see now we have the master applied first then our feature is applied.
In order for this to happen from our branch i.e 'rebase-test' we had to rewind the changes what has happened (application.properites) and then add or playback the changes on master-rebase (pom.xml) on the 'rebase-test'. And then apply the changes on the 'rebase-test' branch. In doing so it flattened my history. And it also allow us to do a fast forward merge once we have done changes on our feature.
14.Now from the feature branch 'rebase-test' we will modify pom.xml
Add the comment for springboot-jpa
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa -->
15. Then do a express commit
$ git commit -am "Comment added for springboot-starter-jpa in pom.xml"
16.Let take a look at our history
$ git log --oneline --decorate --all --graph
/********************************************************************************************/
* b164978 (HEAD -> rebase-test) Comment added for springboot-starter-jpa in pom.xml
* 496b09d logging.file configuration added in application.properties
* 158b30e server.port configuration added in application.properties
* 536dfa5 (master-rebase) comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
/********************************************************************************************/
Now if you see the recent commit has moved up one level. Now the last commit is at the top.
Now i am done with the feature branch lets merge the feature with our master
16. Merging feature branch 'rebase-test' to 'master-rebase'
$ git checkout master-rebase
$ git merge rebase-test
17. Now view the logs
$ git log --oneline --decorate --graph --all
/********************************************************************************************/
* b164978 (HEAD -> master-rebase, rebase-test) Comment added for springboot-starter-jpa in pom.xml
* 496b09d logging.file configuration added in application.properties
* 158b30e server.port configuration added in application.properties
* 536dfa5 comment added for springboot-starter-web in pom.xml
* e6f3f9c comment's added for maven-plugin in pom.xml
/********************************************************************************************/
Now we can see both the master-rebase and rebase-test point to the same commit id.
18. Delete the rebase-test branch
Now we have integrated the changes now we can get rid of the branch
$ git branch -d rebase-test

2. Setup for rebasing conflicts
-------------------------------
For this exercise we have created 2 branches
a) master-rebase (master)
b) rebase-conflict (feature)

1. Modify pom.xml in master
Add the message in pom.xml above dependencies tag
<!-- Adding Changes to rebase-master before rebase conflicts -->

2. Then we do a express commit
$ git commit -am "Adding Message in pom.xml Before Rebase Conflicts"

3. Now we switch on to feature branch rebase-conflict
$ git checkout rebase-conflict

4. Now we have to do some conflicting changes
Open pom.xml and modify the following tags description, version and scope.
save.

5. Then we do a express commit
$ git commit -am "Modified pom.xml for conflicts"

6. Now we switch on to master branch
$ git checkout master-rebase.

7. Now we will make some changes on the same file pom.xml so that we will get a conflict.
Open pom.xml and modify the following tags description, version and scope.
save.

8. Then we do a express commit
$ git commit -am "Modifed pom.xml for conflicts"

9. We check the logs
$ git log --oneline --all --graph --decorate
/********************************************************************************************/
* de3926f (HEAD -> master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
| * 92f0c76 (rebase-conflict) Modified pom.xml for conflicts
/********************************************************************************************/
Now on the top we have 2 commits one on each branches. Here we have master-rebase and rebase-conflict which are diverged.
Also we have now completed the setup of raising a conflict.

3. Abort a Rebase.
------------------
We have setup a conflict situation for our pom.xml in master-rebase and rebase-conflict branches.
1. Switch to feature branch
$ git checkout rebase-conflict

2. View difference in pom.xml b/w master-rebase and rebase-conflict
$ git difftool first-branch second-branch
$ git difftool master-rebase rebase-conflict
We have seen that there are many places or lines which will result in a conflict.

3. Now we will try to rebase our master 'master-rebase'
$ git rebase master-rebase
/********************************************************************************************/
First, rewinding head to replay your work on top of it...
Applying: Modified pom.xml for conflicts
Using index info to reconstruct a base tree...
M       pom.xml
Falling back to patching base and 3-way merge...
Auto-merging pom.xml
CONFLICT (content): Merge conflict in pom.xml
error: Failed to merge in the changes.
Patch failed at 0001 Modified pom.xml for conflicts
Use 'git am --show-current-patch' to see the failed patch

Resolve all conflicts manually, mark them as resolved with
"git add/rm <conflicted_files>", then run "git rebase --continue".
You can instead skip this commit: run "git rebase --skip".
To abort and get back to the state before "git rebase", run "git rebase --abort".
/********************************************************************************************/
From this point we have to perform manually. We have different alternatives.
a) To abort rebase : We can abort rebase by typing the command $ git rebase --abort
b) To resolve manully
Manually resolve the file pom.xml and add the file and commit. then do continue the rebase operation by typing the command $ git rebase --continue
c) To skit the commit : you can remove your commit and proceed with a rebase by typing the command $ git rebase --skip

4. Abort Rebase 
As expected the rebase resulted in a conflict so for this we can abort a rebase we type the command
$ git rebase --abort

5.Now check the log
$ git log --oneline --all --graph --decorate
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
| * 92f0c76 (HEAD -> rebase-conflict) Modified pom.xml for conflicts
We can see nothing is changes, we can see the 2 branches are diverged.

4. Rebase Conflict and Resolution
---------------------------------
In order to resolve the conflict we need to swith to rebase-conflict branch
$ git checkout rebase-conflict

1. View the history
$ git log --oneline --all --graph --decorate
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
| * 92f0c76 (HEAD -> rebase-conflict) Modified pom.xml for conflicts
We can see nothing is changes, we can see the 2 branches are diverged.

2.Now do a rebase
$ git rebase master-rebase
/********************************************************************************************/
First, rewinding head to replay your work on top of it...
Applying: Modified pom.xml for conflicts
Using index info to reconstruct a base tree...
M       pom.xml
Falling back to patching base and 3-way merge...
Auto-merging pom.xml
CONFLICT (content): Merge conflict in pom.xml
error: Failed to merge in the changes.
Patch failed at 0001 Modified pom.xml for conflicts
Use 'git am --show-current-patch' to see the failed patch

Resolve all conflicts manually, mark them as resolved with
"git add/rm <conflicted_files>", then run "git rebase --continue".
You can instead skip this commit: run "git rebase --skip".
To abort and get back to the state before "git rebase", run "git rebase --abort".
/********************************************************************************************/
as expected you will get the conflict now we are in a conflicting state during a rebase. we can consider this as a merge-conflict and resolve the conflicts manually and proceed.

3.Now open visual tool and merge the code
git mergetool
manually merge and save the file.

4.Check the status
$ git status
Now we can see the file which we manually resolved the conflict. And its in modified stage and ready to
Note : You can see the file is ready to commit, but don't do an express commit in this stage. Always add the file first whenever there is a conflict.

5. Add the manually resolved file.
$ git add <modified_file>

6. Now proceed with rebase
$ git rebase --continue
Now we have resolved the rebase conflict and our stage has been changed from rebase conflict to branch active state.

7. View the history
$ git log --oneline --all --graph --decorate
/********************************************************************************************/
* 8037714 (HEAD -> rebase-conflict) Modified pom.xml for conflicts
* 9a21424 Conflicts Resolved for pom.xml during rebase
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
* af753d3 Adding Message in pom.xml Before Rebase Conflicts
* baa6a97 (origin/master, master) modified source
/********************************************************************************************/
Now that we can see that we have aplied our master commit. and then our feature branch commit.	

8. Now we change the pom.xml file again
Save and check the status $ git status

9. Do Express commit
$ git commit -am "Commiting code after rebase conflict"

10. View the history
$ git log --oneline --all --graph --decorate
/********************************************************************************************/
* 8f1875d (HEAD -> rebase-conflict) Commiting code after rebase conflict
* 8037714 Modified pom.xml for conflicts
* 9a21424 Conflicts Resolved for pom.xml during rebase
* de3926f (master-rebase) Modifed pom.xml for conflicts in master-branch
/********************************************************************************************/
Now we can see that our latest commit has come at the top.

11. Now we are done with our changes let merge it to our master branch
$ git checkout master-rebase
$ git merge rebase-conflict

12. View the history
$ git log --oneline --graph --all --decorate
* 8f1875d (HEAD -> master-rebase, rebase-conflict) Commiting code after rebase conflict
* 8037714 Modified pom.xml for conflicts
* 9a21424 Conflicts Resolved for pom.xml during rebase
Now we can see that both the master-rebase, rebase-conflict branch point to the same commit.


4. Pull with Rebase (How to Rebase Incomming changes from github on to your local repository)
---------------------------------------------------------------------------------------------
In this example i want to show some incoming changes from github on to our local repository.

For this example we create a branch rebase-pull
$ git branch rebase-pull
$ git checkout rebase-pull
1. Modify the file pom.xml
Save
2. Express Commit pom.xml
$ git commit -am "local : Changes to pom.xml"

3. Go to browser github select the branch and modify pom.xml
Save

4. Commit the file and give the message "remote: simple changes to pom.xml from browser"

5. Now in gitbash check the status
$ git status

6. Update the reference on the local from the remote repository by giving fetch command
$ git fetch origin rebase-pull

7. Now check the status
$ git status
Now we can see that your branch and the 'origin/rebase-master' have diverged and have 1 and 1 different commit each.

8. Now we do a rebase
Now lets say i want to continue working i am not ready to merge like a traditional merge.
So what i need is i rather put my commit or my changes ahead of what ever is there on github (rebase-pull branch). But i want the benefit of any changes that may have occured in github. so for that we can issue the git pull command by passing in an extra parameter because of rebase during the process.

$ git pull --rebase origin rebase-pull
So this is our standard command, except that now we are using the --rebase option because of rebase instead of normal merge.
Press Enter, now we have rebased our changes from github on top of our master branch on our local repository. 

9. Now check the status
$ git status
Now we can see that our branch is simply ahead of 'origin/rebase-pull' by one commit.

10. View the history
$ git log --oneline --all --graph --decorate
So we can see our origin/rebase-pull and our rebase-pull branch, the local rebase-pull branch is on top on origin/rebase-pull.

-----------
+ Stashing
-----------
In this session we will look upon various scenarios to execute a stash.

1. Simple Stash Example
-----------------------
Create a branch called 'master-stash' and 'stash-test'

1. Switch on to master-stash branch
Modify the pom.xml and Save.

2. Now check the status
$ git status
We can see that the pom.xml is modified. However the pom.xml in my case is going to be a work-in-progress i am not ready to commit the file in this state. However i need to change my gears and modify a different file for something that has to get right now. In order to save the changes that i have for pom.xml i can use git stash command to shash away any changes that are work-in-progress. So that i can change gears and work-on something else.

3. Save the Work-In-Progress File using Stash command
$ git stash
or $ git stash save
When we type git stash by default it will execute the save command. 
When i pressed Enter i got the below message
Saved working directory and index state WIP on master-stash: baa6a97 modified source

4. Now check the status
$ git status
Now we can see that we are in a clean working directory. There are no files in the staging area for commit or anything that is in the staging area. So if i open my pom.xml i can see that its the same file. and i am not able to see my recent changes.

5. Add changes to application.properties
Well lets go and do some changes i open the application.properties file and add the server.port=8009
Save

6. Now check the status
$ git status
Now you can see that the application.properties is modified.

7. Commit the file
Now we do an express commit
$ git commit -am "master : Changes to application.properties in master-stash branch"

8. Now check the status
$ git status
Now we can see that we are in a clean working directory.

9. Fetching or Retrieving the stashed Work-In-Progress File
Now how do we retrieve the stashed file, now that i have completed the high priority task i want to resume my work where i stopped. so how do i retrieve my saved file.
So for this we need to apply our stash, type the command
$ git stash apply
Now lets review the changes, the git stash apply will then give us a git status basically on our working directory which applies what action that the git stash apply command has to do. In this case it put back the pom.xml file into its original stage which is in the working directory changes. Git status also gives us the same information.
Now lets open and verify the pom.xml file. We can see that the discription is back to the was it (<description>From Master. Understanding Stashing Example</description>) before issueing a git stash command. Now we can continue our work from this point onwards. do the necessary changes and save

8. Now check the status
$ git status
Now we can see the modified file pom.xml

9. Commit the changes
Let do an express commit 
$ git commit -am "In Master modifying pom.xml"
Now we are done with our commits.

10. Now check the status
$ git status
Now we can see that we are in a clean working directory.

Save Command
------------
Saves the file
$ git stash save, the save command is optional we can also type git stash

Stash the file with a stash message
-----------------------------------
However to stash before we used the command
the git stash command is fine if you are doing only one stash at a time. But in this case i actually want to specify a stash message so this one is going to be like a commit message, but for a stash. This will make us easier to differentiate between different stashes.
$ git stash save "simple changes for pom.xml"
Now we have created a stash with the stash message "simple changes for pom.xml"

List Command
------------
Now lets look at the list subcommand of stash
$ git stash list : list's all the stashes
stash@{0}: WIP on master-stash: baa6a97 modified source

We have a single item 'stash@{0}:' which is referenced at 0 where we start off with any list. 
'WIP' indicated its Work-In-Progress
and the master-stash is the branch with the reference Id 'baa6197'
and next is the commit message.
Since we have already applied the stash we do not need it anymore, which means we can drop the stash

Drop a stash
------------
To drop a stash type the command
$ git stash drop
Dropped refs/stash@{0} (ed493b4498d5df52d64f8264d31af797c1c07cf1)
And that would drop the last stash.

Droping a specific stash reference
----------------------------------
In order to drop a specific stash reference we use the command git stash drop stash_reference.
$ git stash drop stash@{1}

Delete all the stashes from the stash list
------------------------------------------
There might be a situation we need to delete or clear all the stashes from the stash list then we use the clear command.
$ git stash clear

eg: 
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml

$ git stash clear
This will empty all the stashes in the list.

Picking our a specific stash
----------------------------
For picking up a specific stash we use the command git stash show reflog_syntax
where reflog syntax allows us to reference the specific stash to show and that would be "stash" and then "@" symbol and then, in curly braces, the stash index you wish to look at, in this case i am going to use "1".
eg : $ git log show stash@{1}
$ git stash show stash@{1}
 src/main/resources/application.properties | 5 ++++-
And then in comes back and tells us that application.properties is a part of that stash.

Applying stash to a new branch
------------------------------
Now lets go and apply stash to a new branch. And in order do so we have the below syntax
	$ git stash branch branchName
		where branchName is the name of the branch
And to do that we are going to issue the command 
$ git stash branch branch-stash-test


2. Stashing Untracked files and Using Pop
-----------------------------------------
By default stash command will only stash tracked files.

$ git ls-files - tracks all the files that GIT is monitoring

$ git ls-files
.gitignore
.mvn/wrapper/MavenWrapperDownloader.java
.mvn/wrapper/maven-wrapper.jar
.mvn/wrapper/maven-wrapper.properties
mvnw
mvnw.cmd
pom.xml
src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
src/main/resources/application.properties
src/main/resources/banner.txt
src/test/java/com/xyz/spring/raul/SpringbootDemoApplicationTests.java

1.So we open our pom.xml
Modify the pom file by including some comments like <!-- Springboot Web Dependency -->	& <!-- Springboot JPA Dependency -->
Save the file.

2.We check the status
$ git status
We can see that we have the "Changes not staged for commit" This is the status that is given to working directory changes for files that are been tracked by git. However if i decide to add a new file.

3.Adding a new file
$ npp newFile.txt

4.We check the status
$ git status
Now if you check the status, we have a slightly different status for new files; these are files that Git is not tracking yet. So if i do a "git stash" git stash will only get the modified file which is pom.xml

5.Do a Git Stash
$ git stash
Saved working directory and index state WIP on master-stash: baa6a97 modified source
to verify this we  check the status

6.We check the status
$ git status
On branch master-stash
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

nothing added to commit but untracked files present (use "git add" to track)

We still have the untracked file. which means our working directory is not clean. So i am going to re-apply.

For that we first pop the stashed file so that we can have both the tracked and untracked file. so for that we do a git stash apply
$ git stash apply.

Secondly we delete the value in the stack git stash drop
$ git stash drop

Finally we verify we don't have any stashed files by the list attribute
$ git stash list
now we can see that we don't have any stashes pending.

If we check the status
$ git status
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

no changes added to commit (use "git add" and/or "git commit -a")

7.Stashing an untracked file.
To stash an untracked file we have couple of options, we could simply add the new file to the Git Staging Area. So once that occurs Git will start tracking the file. However if you are not sure if you want to add that file, but you still want to stash it so you can determine that later, then we have an extra parameter for the git stash command. 
Well let's do that now so we just do a git stash -u
$ git stash -u
Then git stash command will then include any untracked files. that are not being excluded by .gitignore. Now if we do a git status

8.We check the status
$ git status
Now we have a clean working directory.

9.Verify the stashes
$ git stash list
stash@{0}: WIP on master-stash: baa6a97 modified source
We can see we have one stash file.

10.Modify the application.properties files
we add the
## Doing an emergency fix after our stash.
server.port=8088
Save the file.

11.Now commit the application.properties
$ git commit -am "Adding Fix after doing stashing files"

12.Verify the status
$ git status
Now we have a clean working directory.

13.Applying the changes from stash
After we have done our emergency fix, Now lets go ahead and apply our changes that we have in our stash. However this time i am going to show you an express way of doing that. Earlier we have to do two commands
a) $ git stash apply
b) $ git stash drop
Now if we want to apply and drop the last stash in the list of stashes so now we can do that in one command 
$ git stash pop
For people who are coming from a programming background this is like popping the stack.
$ git stash pop
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

no changes added to commit (use "git add" and/or "git commit -a")
Dropped refs/stash@{0} (a29afbbce926d2c53d7cfb96ae51d5466f64a868)

Now we have the modified file pom.xml and our untracked file newFile.txt back in our working directory. Now if you see the console message "Dropped refs/stash@{0} (a29afbbce926d2c53d7cfb96ae51d5466f64a868)" means we have droped the stash too.

14.Verify the status
$ git status
Now we have both the modified file and the untracked file in the working directory.

15.Deleting the untracked file.
We are not interested in the new file, so we are deleting it.
$ rm newFile.txt

16.Verifying the status
$ git status
Now we can see only the modified pom.xml file.

17.Commit the file.
We do an express commit.
$ git commit -am "Commiting the file after doing a git stash pop command."

18.Verifying the status
$ git status
Now we have a clean working directory.


3. Managing Multiple Stashes
----------------------------
I am in a clean working directory master-stash branch. Now lets work with multiple stashes by modifying couple of files from the working directory.

1.Modify pom.xml
Modify pom.xml by providing the comment for jpa and web.
Save.

If we do a git status
$ git status
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   pom.xml

no changes added to commit (use "git add" and/or "git commit -a")


2.Stash the file.
However to stash before we used the command
$ git stash 
the git stash command is fine if you are doing only one stash at a time. But in this case i actually want to specify a stash message so this one is going to be like a commit message, but for a stash. This will make us easier to differentiate between different stashes.
$ git stash save "simple changes for pom.xml"
Now we have created our first stash.

3.Modify application.properties
Modify applcation.properties by adding 
server.port=8099
Save.

4.Stash the file.
$ git stash save "simple changes for application.properties"
Now we have created our second stash.

5. Modify SpringbootDemoApplication.java
Provide a line in our main method()
eg. System.out.println("Multiple Stashing Example for Git");

6.Stash the file.
$ git stash save "simple changes for SpringbootDemoApplication.java"
Now we have created our third stash.

7.List all stashes
In order to list all the stashes we use the command
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml

Now you can see that the stash index is probably the reverse of what you are expecting; that the last stash in index "{0}". Now the index "{0}" may be a thing that's throwing you off as well but that comes from a programming background, where the indexs of the list or arry start with index 0. But the point to note here is the last stash is index 0 not 2. 

8.Picking our a specific stash
For picking up a specific stash we use the command git stash show reflog_syntax
where reflog syntax allows us to reference the specific stash to show and that would be "stash" and then "@" symbol and then, in curly braces, the stash index you wish to look at, in this case i am going to use "1".
eg : $ git log show stash@{1}
$ git stash show stash@{1}
 src/main/resources/application.properties | 5 ++++-
And then in comes back and tells us that application.properties is a part of that stash.

9.Verify the status
If we type $ git status we can see that we have a clean working directory.
$ git status

10.Reapply stash
Now we will reapply one of the stashes. So unlike other commands, we can specify the specific stash we want to apply with our "git stash apply" command. So currently we have a clean working directory and we can reapply the stash by the command
Say we need to apply the middle stash. so for this first we list out the all the stashes
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml
Now i want to apply the application.properties changes to my working directory
For that i use the command git stash apply and then the stash reference "stash@{1}"
$ git stash apply stash@{1}
On branch master-stash
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/resources/application.properties

no changes added to commit (use "git add" and/or "git commit -a")

Now git stash will apply the specific changes that's captured in the stash. So now we have our modified application.properites file.


11.Verify the status
$ git status
git status tells us that we have our modified "application.properites" file which is the same output from git stash apply command. Like the other commands we have covered the drop command will also take the stash reference. 
so lets do a git stash list to see our list of stashes

$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: application.properties changes
stash@{2}: On master-stash: simple changes for pom.xml

And now we have applied the stash reference{1} which is the application.properties changes. I dont need them anymore so i am going to drop them. 

12.Droping stash reference of index 1
In order to drop a specific stash reference we use the command git stash drop stash_reference.
$ git stash drop stash@{1}
Dropped stash@{1} (2c73fcfa0857123550489171c1721f94067570a1)
The stash has been droped. Now if we use the list command

13.Listing all stashes
$ git stash list
stash@{0}: On master-stash: simple changes for SpringbootDemoApplication.java
stash@{1}: On master-stash: simple changes for pom.xml

We can see the stash with application.properties changes is not longer there; its no longer listed in our list of stashes. Also what's interesting is that the next stash available has gone in to populate the stashes at {1}, which is simple changes.

14.Delete remaining stashes
So next let's just say that the rest of the stashes I no longer need, for what ever reason. so i use the git stash clear command.
$ git stash clear

15.Listing all stashes
$ git stash list
Now we can see that the list is empty we have no results.


4.Stashing into a branch
-------------------------
We have seen how to stash a file or files to a stash list. In this example we are going to see how can we stash the files to a branch.

1.Modify pom.xml, application.properites and SpringbootDemoApplication.java.
Make a small tweeks in the above 3 files.

- Modify pom.xml
Modify pom.xml by providing the comment for jpa and web.
Save

- Modify application.properties
server.port=8099
Save

- Modify SpringbootDemoApplication.java
System.out.println("Multiple Stashing Example for Git");
Save

2.Verify the status
$ git status 
Now as you can see that i have 3 modified files.

3.Add one file to staging area
So lets add pom.xml to staging area
$ git add pom.xml

4.Verify the status
$ git status 
We have pom.xml in the changes to be commited state which is in the staging area, and the rest are just not staged for commit; basically the modified files is in the working directory.

5.Adding a new file
Just for our complete demo we will add a new file.
$ npp newFile.txt
and we wrote New Contents as text.
Save.

6.Verify the status
$ git status
On branch stash-master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   pom.xml

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
        modified:   src/main/resources/application.properties

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

So now we have files in 3 different buckets of Git. 
1)Changes to be commited - thats the Git staging area that contains the pom.xml file.
2)Changes not staged for commit - Two files that are modified in the working directory, so that's changes not staged for commit. files application.properites and SpringbootDemoApplication.java.
3)Untracked files - Files that are not yet tracked by Git. Our new file newFile.txt lies with in this bucket.

So doing all this work perhaps i have realized that this really does belong on a new feature branch not against master. So one of the favourite ways of all developers to correct this is actually to user Git's stash command to move all these changes to a feature branch.

7.Moving all the changes to a feature branch
So doing all this work perhaps i have realized that this really does belong on a new feature branch not against master. So one of the favourite ways of all developers to correct this is actually to user Git's stash command to move all these changes to a feature branch. so lets do that.
First we need to add all the files that have been modified or that are new to a stash.
$ git stash -u
where -u parameter we are saving not only the modified files but also new files.

8.Verify the status
$ git status
No local changes to save

By doing a git status command we now have a clean working directory.

9.Applying stash to a new branch
Now lets go and apply stash to a new branch. And to do that we are going to issue the command 
	$ git stash branch branchName
		where branchName is the name of the branch

$ git stash branch branch-stash-test
Switched to a new branch 'branch-stash-test'
<stdin>:9: trailing whitespace.
<!-- Starter JPA Beg-->
warning: 1 line adds whitespace errors.
On branch branch-stash-test
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   pom.xml

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
        modified:   src/main/resources/application.properties

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

Dropped refs/stash@{0} (563ae07143d6384033e4ef0ae4899987bc60d23d)

When i pressed Enter, several things happened all at once. First of all the the new branch branch-stash-test is created. Then we switched into that branch, and then our stash is applied. And at the very end that same stash is dropped. We can confirm that by listing all the stashes
	$ git stash list
	It comes as empty. Currently there are no stashes in the stash list. And if we do a git status then we have the same output.
	
	
10.Verify the status
$ git status
On branch branch-stash-test
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        modified:   pom.xml

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java
        modified:   src/main/resources/application.properties

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        newFile.txt

Now we can see that we got the same output as the git stash branch command gave us; basically the same git status that we had back on stash-master prior to issuing the git stash command.

11.Commiting our changes
Now that we have done all this, lets go and ahead and commit our changes that we have.
$ git add .
Now we have added all the files to the staging area
Now all the files are being modified and are in the changes to be commited state, that is our git staging area. So now all we have to do is commit.
$ git commit -m "Changes after git status branch command we have stashed our new changes to a new branch"

Now we have successfully commited our changes.
So at this point i am done with this branch and i am going to integrate these changes to master-stash branch.

12.Switching to master-stash branch
So at this point i am done with this branch and i am going to integrate these changes to master-stash branch. So i am switching to our master branch
$ git checkout master-stash

13.Merge the new changes
Now we are in master branch, lets merge the new changes from branch-stash-test branch to our master branch.
$ git merge branch-stash-test
Updating baa6a97..9d3ccf4
Fast-forward
 newFile.txt                                                      | 1 +
 pom.xml                                                          | 2 ++
 src/main/java/com/xyz/spring/raul/SpringbootDemoApplication.java | 1 +
 src/main/resources/application.properties                        | 3 ++-
 4 files changed, 6 insertions(+), 1 deletion(-)
 create mode 100644 newFile.txt

Now that we have done that which resulted in a fast forward merge. So lets get rid of the branch-stash-test branch

14.Deleting branch-stash-test branch
git branch -d branch-stash-test

Now that branch-stash-test branch is being deleted. if we list the branch
$ git branch 
this lists out all the local branches but we can't see branch-stash-test branch.

-----------
+ Stashing
-----------








